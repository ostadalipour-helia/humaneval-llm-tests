{
  "timestamp": "2025-10-09T14:00:16.628221",
  "problem_id": "HumanEval_156",
  "status": "success",
  "prompt": "You are a Python developer writing unit tests to improve code coverage.\n\nThe following code has some lines that are not covered by existing tests:\n\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000 (inclusive).\")\n\n    roman_map = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n        (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n        (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"),\n        (1, \"I\")\n    ]\n\n    roman_numeral = []\n    for value, symbol in roman_map:\n        while number >= value:\n            roman_numeral.append(symbol)\n            number -= value\n    \n    return \"\".join(roman_numeral).lower()\n\n**Uncovered line numbers:** [13]\n\n**Actual uncovered lines:**\nLine 13:         raise ValueError(\"Number must be between 1 and 1000 (inclusive).\")\n\nGenerate ONLY test method definitions (def test_xxx) that will execute these uncovered lines.\n- Generate 1-3 test methods\n- Each method should be a standalone unittest method\n- Use proper 4-space indentation for method body\n- DO NOT include: class definitions, import statements, or if __name__ blocks\n- Return ONLY the method definitions\n\nExample format:\n    def test_edge_case(self):\n        result = int_to_mini_roman(test_input)\n        self.assertEqual(result, expected)\n\nNow generate the test methods:\n",
  "response": "def test_value_error_for_number_less_than_one(self):\n        with self.assertRaises(ValueError) as cm:\n            int_to_mini_roman(0)\n        self.assertEqual(str(cm.exception), \"Number must be between 1 and 1000 (inclusive).\")\n\n    def test_value_error_for_number_greater_than_one_thousand(self):\n        with self.assertRaises(ValueError) as cm:\n            int_to_mini_roman(1001)\n        self.assertEqual(str(cm.exception), \"Number must be between 1 and 1000 (inclusive).\")",
  "response_length": 479
}