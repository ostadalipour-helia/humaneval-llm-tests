================================================================================
COVERAGE ENHANCEMENT LOG
================================================================================
Problem ID: HumanEval_139
Timestamp: 2025-10-09T13:59:50.512437
Status: success
================================================================================

================================================================================
PROMPT
================================================================================
You are a Python developer writing unit tests to improve code coverage.

The following code has some lines that are not covered by existing tests:

import math

def special_factorial(n):
    """The Brazilian factorial is defined as:
    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
    where n > 0

    For example:
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """
    if not isinstance(n, int):
        raise TypeError("Input must be an integer.")
    if n <= 0:
        raise ValueError("Input 'n' must be a positive integer (n > 0).")

    result = 1
    for i in range(1, n + 1):
        result *= math.factorial(i)
    return result

**Uncovered line numbers:** [16, 18]

**Actual uncovered lines:**
Line 16:         raise TypeError("Input must be an integer.")
Line 18:         raise ValueError("Input 'n' must be a positive integer (n > 0).")

Generate ONLY test method definitions (def test_xxx) that will execute these uncovered lines.
- Generate 1-3 test methods
- Each method should be a standalone unittest method
- Use proper 4-space indentation for method body
- DO NOT include: class definitions, import statements, or if __name__ blocks
- Return ONLY the method definitions

Example format:
    def test_edge_case(self):
        result = special_factorial(test_input)
        self.assertEqual(result, expected)

Now generate the test methods:


================================================================================
RESPONSE
================================================================================
def test_type_error_on_non_integer_input(self):
        with self.assertRaises(TypeError) as cm:
            special_factorial(1.5)
        self.assertEqual(str(cm.exception), "Input must be an integer.")

    def test_value_error_on_non_positive_input(self):
        with self.assertRaises(ValueError) as cm:
            special_factorial(0)
        self.assertEqual(str(cm.exception), "Input 'n' must be a positive integer (n > 0).")

